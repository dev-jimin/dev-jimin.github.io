{"pages":[{"title":"About Roy","text":"Intro.안녕하세요.Roy.","link":"/about/index.html"}],"posts":[{"title":"정렬 (Sort)","text":"정렬 알고리즘(sorting algorithm)이란 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다. 효율적인 정렬은 탐색이나 병합 알고리즘처럼 (정렬된 리스트에서 바르게 동작하는) 다른 알고리즘을 최적화하는 데 중요하다. 분류정렬 알고리즘은 다양한 기준으로 분류된다. 원소들의 크기 비교에 따른 계산 복잡도 원소들의 교환 횟수에 따른 계산 복잡도 메모리 사용량 안정성 직렬과 병렬 오늘 포스팅할 정렬은 알고리즘 문제에서 가장 자주 출제되는 알고리즘이다. 선택 정렬 시간 복잡도 : O(n^2) 123for i = 0 to n: a[i]부터 a[n - 1]까지 차례로 비교하여 가장 작은 값이 a[j]에 있다고 하자. a[i]와 a[j]의 값을 서로 맞바꾼다. 예시 123456789101112131415void selectionSort(int[] list) { int indexMin, temp; for (int i = 0; i &lt; list.length - 1; i++) { indexMin = i; for (int j = i + 1; j &lt; list.length; j++) { if (list[j] &lt; list[indexMin]) { indexMin = j; } } temp = list[indexMin]; list[indexMin] = list[i]; list[i] = temp; }} 삽입 정렬 시간 복잡도 : O(n^2) 삽입 정렬(揷入整列, insertion sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다. 각 반복에서 정렬되지 않은 나머지 부분 중 첫 번째 항목은 제거되어 정확한 위치에 삽입된다. 그러므로 다음과 같은 결과가 된다. 배열이 길어질수록 효율이 떨어진다. 다만, 구현이 간단하다는 장점이 있다. 자기 보다 왼쪽에 작은 수가 나올 때 까지 오른쪽으로 밀어낸다. 왼쪽에 자기 보다 작은 수가 나오면 삽입 한다. 반복 예시 123456789101112void insertionSort(int[] arr) { for(int index = 1 ; index &lt; arr.length ; index++){ int temp = arr[index]; int aux = index - 1; while( (aux &gt;= 0) &amp;&amp; ( arr[aux] &gt; temp ) ) { arr[aux+1] = arr[aux]; aux--; } arr[aux + 1] = temp; }} 거품 정렬 시간 복잡도 : O(n^2) 거품 정렬( - 整列, bubble sort, sinking sort)은 두 인접한 원소를 검사하여 정렬하는 방법이다. 시간 복잡도가 O(n^2)로 상당히 느리지만, 코드가 단순하기 때문에 자주 사용된다. 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이다. 양방향으로 번갈아 수행하면 칵테일 정렬이 된다. 좌측 값이 자기 보다 크면 교환 한다. 반복 예시 123456789101112void bubbleSort(int[] arr) { int temp = 0; for(int i = 0; i &lt; arr.length; i++) { for(int j= 1 ; j &lt; arr.length-i; j++) { if(arr[j]&lt;arr[j-1]) { temp = arr[j-1]; arr[j-1] = arr[j]; arr[j] = temp; } } }} 셸 정렬 시간 복잡도 평균 : O(n^1.5) 최악의 경우 : O(n^2) 셸 정렬(shell sort)은 가장 오래된 정렬 알고리즘의 하나이다. 이름은 1959년 이 방법을 발표한 창안자 도널드 셸의 이름을 따서 붙여졌다. 셸 정렬은 개념을 이해하고 구현하기는 쉬우나 시간복잡도 분석은 조금 복잡하다. 자기 보다 왼쪽에 작은 수가 나올 때 까지 간격 만큼 오른쪽으로 밀어낸다. 왼쪽 간격에 자기 보다 작은 수가 나오면 삽입 한다. 간격을 줄인다. 반복 예시 12345678910111213141516171819public void shellSort(Integer[] arr) { int interval = arr.length / 2; while (interval != 0) { for (int i = 0; i &lt; interval; i++) { for (int p = i + interval; p &lt; arr.length; p += interval) { int key = arr[p]; int j = p - interval; while (j &gt;= 0) { if (key &lt; arr[j]) { arr[j + interval] = arr[j]; } else break; j -= interval; } arr[j + interval] = key; } } interval /= 2; } } 퀵 정렬 시간 복잡도 평균 : O(n log n) 최악의 경우 : O(n^2) 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다. 좌측 값이 '축'값 보다 크거나 같은 것을 찾을 때 까지 비교 한다. 우측 값이 '축'값 보다 작거나 같은 것을 찾을 때 까지 비교 한다. 좌측 값과 우측 값을 교환 한다. 좌측 인덱스가 우측 인덱스보다 크면 배열을 분할 한다. 재귀적으로 반복 예시 1234567891011121314151617181920public void quickSort(int[] arr, int left, int right) { int i, j, pivot, tmp; if (left &lt; right) { i = left; j = right; pivot = arr[(left+right)/2]; //분할 과정 while (i &lt; j) { while (arr[j] &gt; pivot) j--; // 이 부분에서 arr[j-1]에 접근해서 익셉션 발생가능함. while (i &lt; j &amp;&amp; arr[i] &lt; pivot) i++; tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } //정렬 과정 quickSort(arr, left, i - 1); quickSort(arr, i + 1, right); }} 병합 정렬 시간 복잡도 : O(n log n) 배열을 최소 단위 까지 분할 한다. 병합 시, 부분 배열의 각 앞에서 부터 순차 비교 후 임시 배열에 삽입한다. 임시 배열을 원본 배열에 복사한다. 반복하여 병합 예시 123456789101112131415161718192021222324/// merge sort range : [low ~ high]void mergeSort(int A[], int low, int high, int B[]){ // 1. base condition if(low &gt;= high) return; // 2. divide int mid = (low + high) / 2; // 3. conquer mergeSort(A, low, mid, B); mergeSort(A, mid+1, high, B); // 4. combine int i=low, j=mid+1, k=low; for(;k&lt;=high;++k){ if(j &gt; high ) B[k] = A[i++]; else if(i &gt; mid) B[k] = A[j++]; else if(A[i] &lt; A[j]) B[k] = A[i++]; else B[k] = A[j++]; } // 5. copy for(i=low;i&lt;=high;++i) A[i] = B[i];} 힙 정렬 시간 복잡도 : O(n log n) n개의 노드에 대한 완전 이진 트리를 구성한다. 이때 루트 노드부터 부모노드, 왼쪽 자식노드, 오른쪽 자식노드 순으로 구성한다. 최대 힙을 구성한다. 최대 힙이란 부모노드가 자식노드보다 큰 트리를 말하는데, 단말 노드를 자식노드로 가진 부모노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다. 가장 큰 수(루트에 위치)를 가장 작은 수와 교환한다. 2와 3을 반복한다. 예시 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Heap { private int[] element; //element[0] contains length private static final int ROOTLOC = 1; private static final int DEFAULT = 10; public Heap(int size) { if(size&gt;DEFAULT) {element = new int[size+1]; element[0] = 0;} else {element = new int[DEFAULT+1]; element[0] = 0;} } public void add(int newnum) { if(element.length &lt;= element[0] + 1) { int[] elementTemp = new int[element[0]*2]; for(int x = 0; x &lt; element[0]; x++) { elementTemp[x] = element[x]; } element = elementTemp; } element[++element[0]] = newnum; upheap(); } public int extractRoot() { int extracted = element[1]; element[1] = element[element[0]--]; downheap(); return extracted; } public void upheap() { int locmark = element[0]; while(locmark &gt;= 1 &amp;&amp; element[locmark/2] &gt; element[locmark]) { swap(locmark/2, locmark); locmark /= 2; } } public void downheap() { int locmark = 1; while(locmark * 2 &lt;= element[0]) { if(locmark * 2 + 1 &lt;= element[0]) { int small = smaller(locmark*2, locmark*2+1); swap(locmark,small); locmark = small; } else { swap(locmark, locmark * 2); locmark *= 2; } } } public void swap(int a, int b) { int temp = element[a]; element[a] = element[b]; element[b] = temp; } public int smaller(int a, int b) { return element[a] &lt; element[b] ? a : b; }} 출처 https://ko.wikipedia.org/wiki/%EC%85%B8_%EC%A0%95%EB%A0%AC https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC https://endorphin0710.tistory.com/42","link":"/2020/11/16/2020-11-16/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"}]}