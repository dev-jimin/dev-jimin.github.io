{"pages":[{"title":"About Roy","text":"Intro.안녕하세요.Roy.","link":"/about/index.html"}],"posts":[{"title":"정렬 (Sort)","text":"정렬 알고리즘(sorting algorithm)이란 원소들을 번호순이나 사전 순서와 같이 일정한 순서대로 열거하는 알고리즘이다. 효율적인 정렬은 탐색이나 병합 알고리즘처럼 (정렬된 리스트에서 바르게 동작하는) 다른 알고리즘을 최적화하는 데 중요하다. 분류정렬 알고리즘은 다양한 기준으로 분류된다. 원소들의 크기 비교에 따른 계산 복잡도 원소들의 교환 횟수에 따른 계산 복잡도 메모리 사용량 안정성 직렬과 병렬 오늘 포스팅할 정렬은 알고리즘 문제에서 가장 자주 출제되는 알고리즘이다. 선택 정렬 시간 복잡도 : O(n^2) 123for i = 0 to n: a[i]부터 a[n - 1]까지 차례로 비교하여 가장 작은 값이 a[j]에 있다고 하자. a[i]와 a[j]의 값을 서로 맞바꾼다. 예시 123456789101112131415void selectionSort(int[] list) { int indexMin, temp; for (int i = 0; i &lt; list.length - 1; i++) { indexMin = i; for (int j = i + 1; j &lt; list.length; j++) { if (list[j] &lt; list[indexMin]) { indexMin = j; } } temp = list[indexMin]; list[indexMin] = list[i]; list[i] = temp; }} 삽입 정렬 시간 복잡도 : O(n^2) 삽입 정렬(揷入整列, insertion sort)은 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다. 각 반복에서 정렬되지 않은 나머지 부분 중 첫 번째 항목은 제거되어 정확한 위치에 삽입된다. 그러므로 다음과 같은 결과가 된다. 배열이 길어질수록 효율이 떨어진다. 다만, 구현이 간단하다는 장점이 있다. 자기 보다 왼쪽에 작은 수가 나올 때 까지 오른쪽으로 밀어낸다. 왼쪽에 자기 보다 작은 수가 나오면 삽입 한다. 반복 예시 123456789101112void insertionSort(int[] arr) { for(int index = 1 ; index &lt; arr.length ; index++){ int temp = arr[index]; int aux = index - 1; while( (aux &gt;= 0) &amp;&amp; ( arr[aux] &gt; temp ) ) { arr[aux+1] = arr[aux]; aux--; } arr[aux + 1] = temp; }} 거품 정렬 시간 복잡도 : O(n^2) 거품 정렬( - 整列, bubble sort, sinking sort)은 두 인접한 원소를 검사하여 정렬하는 방법이다. 시간 복잡도가 O(n^2)로 상당히 느리지만, 코드가 단순하기 때문에 자주 사용된다. 원소의 이동이 거품이 수면으로 올라오는 듯한 모습을 보이기 때문에 지어진 이름이다. 양방향으로 번갈아 수행하면 칵테일 정렬이 된다. 좌측 값이 자기 보다 크면 교환 한다. 반복 예시 123456789101112void bubbleSort(int[] arr) { int temp = 0; for(int i = 0; i &lt; arr.length; i++) { for(int j= 1 ; j &lt; arr.length-i; j++) { if(arr[j]&lt;arr[j-1]) { temp = arr[j-1]; arr[j-1] = arr[j]; arr[j] = temp; } } }} 셸 정렬 시간 복잡도 평균 : O(n^1.5) 최악의 경우 : O(n^2) 셸 정렬(shell sort)은 가장 오래된 정렬 알고리즘의 하나이다. 이름은 1959년 이 방법을 발표한 창안자 도널드 셸의 이름을 따서 붙여졌다. 셸 정렬은 개념을 이해하고 구현하기는 쉬우나 시간복잡도 분석은 조금 복잡하다. 자기 보다 왼쪽에 작은 수가 나올 때 까지 간격 만큼 오른쪽으로 밀어낸다. 왼쪽 간격에 자기 보다 작은 수가 나오면 삽입 한다. 간격을 줄인다. 반복 예시 12345678910111213141516171819public void shellSort(Integer[] arr) { int interval = arr.length / 2; while (interval != 0) { for (int i = 0; i &lt; interval; i++) { for (int p = i + interval; p &lt; arr.length; p += interval) { int key = arr[p]; int j = p - interval; while (j &gt;= 0) { if (key &lt; arr[j]) { arr[j + interval] = arr[j]; } else break; j -= interval; } arr[j + interval] = key; } } interval /= 2; } } 퀵 정렬 시간 복잡도 평균 : O(n log n) 최악의 경우 : O(n^2) 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속한다. 좌측 값이 '축'값 보다 크거나 같은 것을 찾을 때 까지 비교 한다. 우측 값이 '축'값 보다 작거나 같은 것을 찾을 때 까지 비교 한다. 좌측 값과 우측 값을 교환 한다. 좌측 인덱스가 우측 인덱스보다 크면 배열을 분할 한다. 재귀적으로 반복 예시 1234567891011121314151617181920public void quickSort(int[] arr, int left, int right) { int i, j, pivot, tmp; if (left &lt; right) { i = left; j = right; pivot = arr[(left+right)/2]; //분할 과정 while (i &lt; j) { while (arr[j] &gt; pivot) j--; // 이 부분에서 arr[j-1]에 접근해서 익셉션 발생가능함. while (i &lt; j &amp;&amp; arr[i] &lt; pivot) i++; tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp; } //정렬 과정 quickSort(arr, left, i - 1); quickSort(arr, i + 1, right); }} 병합 정렬 시간 복잡도 : O(n log n) 배열을 최소 단위 까지 분할 한다. 병합 시, 부분 배열의 각 앞에서 부터 순차 비교 후 임시 배열에 삽입한다. 임시 배열을 원본 배열에 복사한다. 반복하여 병합 예시 123456789101112131415161718192021222324/// merge sort range : [low ~ high]void mergeSort(int A[], int low, int high, int B[]){ // 1. base condition if(low &gt;= high) return; // 2. divide int mid = (low + high) / 2; // 3. conquer mergeSort(A, low, mid, B); mergeSort(A, mid+1, high, B); // 4. combine int i=low, j=mid+1, k=low; for(;k&lt;=high;++k){ if(j &gt; high ) B[k] = A[i++]; else if(i &gt; mid) B[k] = A[j++]; else if(A[i] &lt; A[j]) B[k] = A[i++]; else B[k] = A[j++]; } // 5. copy for(i=low;i&lt;=high;++i) A[i] = B[i];} 힙 정렬 시간 복잡도 : O(n log n) n개의 노드에 대한 완전 이진 트리를 구성한다. 이때 루트 노드부터 부모노드, 왼쪽 자식노드, 오른쪽 자식노드 순으로 구성한다. 최대 힙을 구성한다. 최대 힙이란 부모노드가 자식노드보다 큰 트리를 말하는데, 단말 노드를 자식노드로 가진 부모노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다. 가장 큰 수(루트에 위치)를 가장 작은 수와 교환한다. 2와 3을 반복한다. 예시 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Heap { private int[] element; //element[0] contains length private static final int ROOTLOC = 1; private static final int DEFAULT = 10; public Heap(int size) { if(size&gt;DEFAULT) {element = new int[size+1]; element[0] = 0;} else {element = new int[DEFAULT+1]; element[0] = 0;} } public void add(int newnum) { if(element.length &lt;= element[0] + 1) { int[] elementTemp = new int[element[0]*2]; for(int x = 0; x &lt; element[0]; x++) { elementTemp[x] = element[x]; } element = elementTemp; } element[++element[0]] = newnum; upheap(); } public int extractRoot() { int extracted = element[1]; element[1] = element[element[0]--]; downheap(); return extracted; } public void upheap() { int locmark = element[0]; while(locmark &gt;= 1 &amp;&amp; element[locmark/2] &gt; element[locmark]) { swap(locmark/2, locmark); locmark /= 2; } } public void downheap() { int locmark = 1; while(locmark * 2 &lt;= element[0]) { if(locmark * 2 + 1 &lt;= element[0]) { int small = smaller(locmark*2, locmark*2+1); swap(locmark,small); locmark = small; } else { swap(locmark, locmark * 2); locmark *= 2; } } } public void swap(int a, int b) { int temp = element[a]; element[a] = element[b]; element[b] = temp; } public int smaller(int a, int b) { return element[a] &lt; element[b] ? a : b; }} 출처 https://ko.wikipedia.org/wiki/%EC%85%B8_%EC%A0%95%EB%A0%AC https://ko.wikipedia.org/wiki/%ED%80%B5_%EC%A0%95%EB%A0%AC https://ko.wikipedia.org/wiki/%ED%95%A9%EB%B3%91_%EC%A0%95%EB%A0%AC https://ko.wikipedia.org/wiki/%ED%9E%99_%EC%A0%95%EB%A0%AC https://endorphin0710.tistory.com/42","link":"/2020/11/16/2020-11-16/"},{"title":"실패율","text":"2019 KAKAO BLIND RECRUITMENT 문제 설명슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다. 이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라. 실패율은 다음과 같이 정의한다. 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수 전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라. 제한사항 스테이지의 개수 N은 1 이상 500 이하의 자연수이다. stages의 길이는 1 이상 200,000 이하이다. stages에는 1 이상 N + 1 이하의 자연수가 담겨있다. 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다. 단, N + 1 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다. 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 0 으로 정의한다. 입출력 예 N stages result 5 [2,1,2,6,2,4,3,3] [3,4,2,1,5] 4 [4,4,4,4,4] [4,1,2,3] 입출력 예 설명입출력 예 #11번 스테이지에는 총 8명의 사용자가 도전했으며, 이 중 1명의 사용자가 아직 클리어하지 못했다. 따라서 1번 스테이지의 실패율은 다음과 같다. 1 번 스테이지 실패율 : 1/8 2번 스테이지에는 총 7명의 사용자가 도전했으며, 이 중 3명의 사용자가 아직 클리어하지 못했다. 따라서 2번 스테이지의 실패율은 다음과 같다. 2 번 스테이지 실패율 : 3/7 마찬가지로 나머지 스테이지의 실패율은 다음과 같다. 3 번 스테이지 실패율 : 2/4 4번 스테이지 실패율 : 1/2 5번 스테이지 실패율 : 0/1 각 스테이지의 번호를 실패율의 내림차순으로 정렬하면 다음과 같다. [3,4,2,1,5] 입출력 예 #2 모든 사용자가 마지막 스테이지에 있으므로 4번 스테이지의 실패율은 1이며 나머지 스테이지의 실패율은 0이다. [4,1,2,3] 내 풀이123456789101112131415161718192021func solution(_ N:Int, _ stages:[Int]) -&gt; [Int] { var rates: [(stage: Int, rate: Float)] = [] for stage in 1...N { var tryUser: Float = 0 var totalUser: Float = 0 for i in stages { if i == stage { tryUser += 1 } if i &gt;= stage { totalUser += 1 } } rates.append((stage, tryUser / totalUser)) } let result = rates .sorted(by: { (a, b) in a.1 != b.1 ? a.1 &gt; b.1 : a.0 &lt; b.0 }) .map( { $0.0 } ) return result} 1 스테이지 부터 총 스테이지 N 까지 반복 한다. 현재 스테이지와 동일한 사용자는 tryUser 에 +1 하고, 현재 스테이지보다 많이 진행 한 사용자는 totalUser에 +1 한다. 현재 스테이지의 실패율을 구해, 배열에 담아둔다. 실패율에 따라 내림차순으로 정렬한다. 실행 결과 일부 테스트 케이스에서 실패(시간 초과)가 발생 하였다. 원인 분석 최대의 경우의수를 구하면 스테이지 수(N) = 500 stages의 길이 = 200,000 즉, 1억번의 반복문이 실행 되기 때문에 2중 반복문의 사용을 없애야 한다. 다른 풀이1234567891011121314151617181920212223242526func solution(_ N:Int, _ stages:[Int]) -&gt; [Int] { guard N &gt;= 1 &amp;&amp; N &lt;= 500 else { return [] } var failures: [(stage: Int, count: Int, fail: Float)] = Array(repeating: (0, 0, 0), count: N) for i in Array(0..&lt;stages.count) { let index = stages[i] - 1 guard index &gt;= 0 else { continue } guard index &lt; N else { continue } failures[index] = (stages[i], failures[index].count + 1, 0) } var usersCount = stages.count for i in Array(0..&lt;failures.count) { var fail = failures[i] fail.stage = i + 1 fail.fail = usersCount &gt; 0 ? Float(fail.count) / Float(usersCount) : 0 failures[i] = fail usersCount -= fail.count } let sorted = failures .sorted(by: { (s1, s2) in s1.fail == s2.fail ? s1.stage &lt; s2.stage : s1.fail &gt; s2.fail }) .map({ $0.stage }) return sorted} 실패율을 기록할 배열을 생성 첫번 째 반복문에서 현재 스테이지에 도달한 사용자를 카운트 한다. 두번 째 반복문에서 실패율(도달한 사용자 / 전체 사용자)을 계산해준다. 실패율에 따라 내림차순으로 정렬한다. 실행 결과 내 풀이보다 압도적인 실행 속도를 보여주었다. 분석 가장 큰 원인이었던 2중 반복문을 분리 하여, 최대 경우의 수를 500 + 200,000번으로 줄였다.","link":"/2020/11/23/2020-11-23/"},{"title":"[Swift] UIBarButtonItem을 이용한 ToolBar 구현","text":"UIBarButtonItem을 사용하여 아이콘 버튼으로 이루어진 Bottom Tool Bar를 구현 하고자 한다. 아이콘 버튼 생성12345let button = UIButton(type: .custom)button.frame = CGRect(x: 0, y: 0, width: 45, height: 44)button.setImage(UIImage(named: &quot;image-name&quot;), for: .normal)button.tag = ToolBarButtonType.Back.rawValuebutton.addTarget(self, action: #selector(touchedToolBarButton(_:)), for: .touchUpInside) 버튼을 생성하고 이미지와 touchUpInside Event를 추가 해주었다. 버튼에 Tag를 적용 시켜 어떤 버튼이 눌렸는지 구분해주면 좋다. 버튼에 UIView를 사용하여, Badge를 추가 하거나, Title을 설정해 텍스트도 노출 시킬 수 있으니 활용 해보자. 터치 이벤트 구현1234567891011121314@objc func touchedToolBarButton(_ sender: UIButton) { guard let buttonType = ToolBarButtonType.init(rawValue: sender.tag) else { return } switch buttonType { case .Back: /* 이벤트 내용 */ default: break }} UIBarButtonItem 생성1let buttonItem = UIBarButtonItem(customView: button) UIBarButtonItem을 생성 할 때 CustomView를 사용하여 생성해 준다. 미리 생성해둔 아이콘 버튼을 사용한다. 적용1234567override func viewWillAppear(_ animated: Bool) { super.viewWillAppear(animated) let buttonItems: [UIBarButtonItem] = [buttonItem1, buttonItem2 ... buttonItem5] self.setToolbarItems(buttonItems, animated: false)}","link":"/2020/12/18/20201218-swift-uibarbuttonitem/"},{"title":"Android Q Media Store 사용","text":"Android Q 버전 부터 Media Store를 사용해야 외부 저장소 접근이 가능하다고 한다. [ Android 11의 저장소 업데이트 ] 설정 방법은 다음과 같다. Scoped Mode1&lt;application android:requestLegacyExternalStorage=&quot;true&quot;&gt; Manifest.xml에 Android Q 이전 버전에서도 Media Store를 사용할 수 있도록 Scoped Mode 적용 여부 플래그를 추가 해준다. Method1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374private void saveImage(String fileName, Bitmap image) { // Q 이후 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) { ContentValues values = new ContentValues(); values.put(MediaStore.Images.Media.DISPLAY_NAME, file_name); values.put(MediaStore.Images.Media.MIME_TYPE, &quot;image/*&quot;); // 파일을 write중이면 다른곳에서 데이터 요구 무시 values.put(MediaStore.Images.Media.IS_PENDING, 1); ContentResolver contentResolver = getContentResolver(); Uri collection = MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY); Uri item = contentResolver.insert(collection, values); try { ParcelFileDescriptor pdf = contentResolver.openFileDescriptor(item, &quot;w&quot;, null); if (pdf != null) { InputStream inputStream = getImageInputStream(bitmap); byte[] strToByte = getBytes(inputStream); FileOutputStream fos = new FileOutputStream(pdf.getFileDescriptor()); fos.write(strToByte); fos.close(); inputStream.close(); pdf.close(); contentResolver.update(item, values, null, null); } } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } values.clear(); // 이미지를 저장한 후 다른곳에서 사용할 수 있도록 열어준다. values.put(MediaStore.Images.Media.IS_PENDING, 0); contentResolver.update(item, values, null, null); } else { String ex_storage = Environment.getExternalStorageDirectory().getAbsolutePath(); String foler_name = &quot;/imageStore/&quot;; String string_path = ex_storage + foler_name; try { File file_path = new File(string_path); if(!file_path.isDirectory()){ file_path.mkdirs(); } FileOutputStream out = new FileOutputStream(string_path + file_name); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, out); out.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, Uri.parse(&quot;file://&quot; + string_path + file_name))); }}private InputStream getImageInputStream(Bitmap bmp) { ByteArrayOutputStream bytes = new ByteArrayOutputStream(); bmp.compress(Bitmap.CompressFormat.JPEG, 100, bytes); byte[] bitmapData = bytes.toByteArray(); return new ByteArrayInputStream(bitmapData);}private byte[] getBytes(InputStream inputStream) throws IOException { ByteArrayOutputStream byteBuffer = new ByteArrayOutputStream(); int bufferSize = 1024; byte[] buffer = new byte[bufferSize]; int len = 0; while ((len = inputStream.read(buffer)) != -1) { byteBuffer.write(buffer,0,len); } return byteBuffer.toByteArray();} [참고] https://hjiee.tistory.com/","link":"/2021/01/15/android-q-media-store/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"android","slug":"android","link":"/tags/android/"}],"categories":[{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"swift","slug":"swift","link":"/categories/swift/"}]}